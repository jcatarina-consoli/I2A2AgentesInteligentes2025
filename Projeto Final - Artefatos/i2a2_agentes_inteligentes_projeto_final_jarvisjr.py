# -*- coding: utf-8 -*-
"""I2A2_Agentes_Inteligentes_Projeto_Final_JARVISJr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MgGfm0tWi3aHCvipy6uo6wjgHHB26yyI
"""

#@title C√âLULA 1: Infraestrutura (v6.0 - Completa)

import os
import sys
import subprocess
from google.colab import userdata
import logging

def install_dependencies():
    """Instala os pacotes Python estritamente necess√°rios."""
    print("Iniciando instala√ß√£o de depend√™ncias (v6.0 - Completa)...")
    logging.getLogger('pip').setLevel(logging.ERROR) # Suprime logs do pip

    # Lista de pacotes
    pacotes = [
        "streamlit",
        "pyngrok",
        "pandas",
        "matplotlib",
        "google-generativeai",
        "pydantic",
        "openpyxl"
    ]

    try:
        subprocess.check_call([
            sys.executable, "-m", "pip", "install", "-q", "--upgrade", *pacotes
        ])
        print("‚úÖ Depend√™ncias (v6.0) instaladas com sucesso.")
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Erro na instala√ß√£o de depend√™ncias: {e}")
        sys.exit(1)
    finally:
        logging.getLogger('pip').setLevel(logging.INFO) # Restaura o log

def load_environment_secrets():
    """Carrega as chaves de API do Colab Secrets."""
    print("\nCarregando secrets do Colab...")
    try:
        os.environ["GEMINI_API_KEY"] = userdata.get("GEMINI_API_KEY")
        os.environ["NGROK_AUTHTOKEN"] = userdata.get("NGROK_AUTHTOKEN")

        if not os.environ["GEMINI_API_KEY"]:
            print("‚ö†Ô∏è Aviso: 'GEMINI_API_KEY' n√£o encontrada ou vazia.")
        if not os.environ["NGROK_AUTHTOKEN"]:
            print("‚ö†Ô∏è Aviso: 'NGROK_AUTHTOKEN' n√£o encontrada ou vazia.")

        print("‚úÖ Secrets carregados (GEMINI_API_KEY, NGROK_AUTHTOKEN).")

    except Exception as e:
        print(f"‚ùå Falha cr√≠tica ao carregar secrets: {e}")
        print("    Por favor, verifique se os secrets 'GEMINI_API_KEY' e 'NGROK_AUTHTOKEN' est√£o configurados no Colab.")
        sys.exit(1)

# --- Execu√ß√£o Principal ---
install_dependencies()
load_environment_secrets()
print("\n‚úÖ Infraestrutura pronta!")

#@title C√âLULA 2: L√≥gica da Aplica√ß√£o (v7.9 - O Jeito Streamlit)
import os
import io
import sys
import re
import logging
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import streamlit as st
import unicodedata
import time

# --- 1. Cria o arquivo de Tema (.streamlit/config.toml) ---
os.makedirs(".streamlit", exist_ok=True)

config_toml_content = """
[theme]
# Cor prim√°ria (azul/roxo)
primaryColor="#5A55D1"
# Cor de fundo principal (cinza bem claro)
backgroundColor="#F4F6F9"
# Cor de fundo de widgets e cart√µes (branco)
secondaryBackgroundColor="#FFFFFF"
# Cor do texto principal (cinza escuro)
textColor="#1F1F1F"
# Fonte padr√£o
font="sans serif"
"""
try:
    with open(".streamlit/config.toml", "w") as f:
        f.write(config_toml_content)
    print("‚úÖ Arquivo de tema 'config.toml' (v7.9) criado com sucesso.")
except Exception as e:
    print(f"‚ùå Erro ao escrever config.toml: {e}")


# --- 2. Cria o App (app.py) ---
app_py_content = """
import os
import io
import sys
import re
import logging
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import streamlit as st
import unicodedata # Para normalizar nomes de arquivos
import time # Para simular carregamento

# Imports de IA (Nativo do Google)
import google.generativeai as genai
from google.generativeai.types import GenerationConfig, FunctionDeclaration, Tool

# Configura o backend do Matplotlib
matplotlib.use("Agg")

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)

# Vari√°vel global para o DataFrame
df_global = None

def _slugify(text):
    \"\"\"
    Converte texto em um "slug" seguro para nomes de arquivos.
    Ex: "MUNIC√çPIO EMITENTE" -> "municipio_emitente"
    \"\"\"
    try:
        text = unicodedata.normalize('NFD', text)
        text = text.encode('ascii', 'ignore').decode('utf-8')
    except Exception:
        pass

    text = text.lower()
    text = re.sub(r'[^a-z0-9_\\-]', '_', text)
    text = re.sub(r'__+', '_', text)
    text = text.strip('_')

    if not text:
        text = "arquivo_grafico"

    return text

def load_custom_css():
    \"\"\"Injeta CSS customizado (M√çNIMO) para o design 'Bigscoots'.\"\"\"
    st.markdown(\"\"\"
        <style>
            /* Fonte principal */
            html, body, [class*="st-"] {
                font-family: 'sans serif', sans-serif;
            }

            /* Esconde o cabe√ßalho padr√£o do Streamlit */
            .stApp [data-testid="stHeader"] {
                display: none; /* Esconde o header com o menu */
            }

            /* --- Barra Lateral (Sidebar) --- */
            [data-testid="stSidebar"] {
                background-color: #312E81; /* Fundo Roxo/Azul Escuro */
                padding-top: 1.5rem;
            }

            /* T√≠tulos e textos na sidebar (for√ßados a serem claros) */
            [data-testid="stSidebar"] h1 { color: #FFFFFF !important; }
            [data-testid="stSidebar"] h2 { color: #FFFFFF !important; }
            [data-testid="stSidebar"] .stMarkdown p { color: #E0E0E0 !important; }

            /* --- Abas (Tabs) --- */
            .stTabs [data-baseweb="tab"] {
                border-radius: 6px 6px 0 0;
            }

            /* --- Cart√µes (Dashboard e Chat) --- */
            /* Damos aos containers de chat e dashboard uma borda e sombra */
            [data-testid="chat-message-container"] {
                border-radius: 12px;
                padding: 1.25rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.04);
                border: 1px solid #E5E7EB;
            }
            [data-testid="chat-message-container"]:has([data-testid="chat-avatar-user"]) {
                background-color: #F4F6F9; /* Fundo cinza claro para user */
            }

            [data-testid="stMetric"] {
                background-color: var(--secondaryBackgroundColor); /* Branco */
                border: 1px solid #E5E7EB;
                border-radius: 10px;
                padding: 1.5rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.04);
            }
        </style>
    \"\"\", unsafe_allow_html=True)


# --- 2. Fun√ß√µes de Carregamento (Sem altera√ß√µes da v6.1) ---

def carregar_arquivos_upload(lista_de_arquivos_upload, **kwargs):
    \"\"\"Carrega e concatena arquivos CSV/Excel do st.file_uploader.\"\"\"
    dataframes = []

    if not lista_de_arquivos_upload:
        st.error("Nenhum arquivo enviado.")
        return None

    csv_configuracoes_prioritarias = [
        {'sep': ';', 'decimal': ',', 'encoding': 'latin-1'},
        {'sep': ';', 'decimal': '.', 'encoding': 'latin-1'},
    ]
    csv_separadores_fallback = [',', '\t', '|']
    csv_encodings_fallback = ['Windows-1252', 'utf-8']

    progress_bar = st.progress(0, "Carregando arquivos...")

    for i, arquivo_upload in enumerate(lista_de_arquivos_upload):
        temp_df = None; sucesso = False
        file_extension = os.path.splitext(arquivo_upload.name)[1].lower()
        logging.info(f"  Tentando carregar: {arquivo_upload.name} (Tipo: {file_extension})")

        arquivo_upload.seek(0)

        if file_extension == '.csv':
            for config in csv_configuracoes_prioritarias:
                try:
                    temp_df = pd.read_csv(arquivo_upload, **config, engine='python', on_bad_lines='warn', **kwargs)
                    arquivo_upload.seek(0)
                    if len(temp_df.columns) > 1: sucesso = True; break
                except Exception:
                    arquivo_upload.seek(0); continue

            if not sucesso:
                for sep in csv_separadores_fallback:
                    for enc in csv_encodings_fallback:
                        try:
                            temp_df = pd.read_csv(arquivo_upload, sep=sep, encoding=enc, engine='python', on_bad_lines='warn', **kwargs)
                            arquivo_upload.seek(0)
                            if len(temp_df.columns) > 1: sucesso = True; break
                        except Exception:
                            arquivo_upload.seek(0); continue
                    if sucesso: break

        elif file_extension in ['.xlsx', '.xls']:
            try:
                temp_df = pd.read_excel(arquivo_upload, engine='openpyxl', **kwargs)
                if len(temp_df.columns) > 1: sucesso = True
            except Exception as e:
                logging.error(f"Erro ao ler arquivo Excel {arquivo_upload.name}: {e}")
                st.warning(f"Erro ao ler Excel {arquivo_upload.name}: {e}")

        else:
            st.warning(f"Formato de arquivo '{file_extension}' n√£o suportado para {arquivo_upload.name}.")

        if sucesso:
            dataframes.append(temp_df)
        else:
            logging.warning(f"‚ùå Falha ao carregar o arquivo {arquivo_upload.name}.")
            st.warning(f"N√£o foi poss√≠vel ler o arquivo: {arquivo_upload.name}. Verifique o formato ou encoding.")

        progress_bar.progress((i + 1) / len(lista_de_arquivos_upload), f"Carregando: {arquivo_upload.name}")

    if dataframes:
        try:
            time.sleep(0.5)
            df_concat = pd.concat(dataframes, ignore_index=True)
            logging.info(f"\\n‚úÖ DataFrame 'df' carregado. Shape final: {df_concat.shape}")
            progress_bar.success("Arquivos carregados e concatenados!")
            time.sleep(0.5)
            return df_concat
        except Exception as e:
            logging.error(f"‚ùå Erro ao concatenar DataFrames: {e}")
            st.error(f"Erro ao concatenar arquivos: {e}")
            return None
    else:
        logging.error("‚ùå Nenhum DataFrame foi carregado.")
        st.error("Nenhum arquivo CSV/Excel p√¥de ser lido com sucesso.")
        return None

def run_data_wrangling(df):
    \"\"\"Aplica a limpeza de dados e valida√ß√£o fiscal.\"\"\"
    if df is None: return None

    wrangling_placeholder = st.empty()
    wrangling_placeholder.text("Iniciando limpeza e valida√ß√£o dos dados...")

    COLUNA_CHAVE = 'CHAVE DE ACESSO'; COLUNA_DATA = 'DATA EMISS√ÉO'; COLUNA_VALOR = 'VALOR NOTA FISCAL'
    COLUNAS_CHAVE_COMPOSTA = ['S√âRIE', 'N√öMERO', 'MUNIC√çPIO EMITENTE', 'CPF/CNPJ Emitente']

    total_linhas_original = len(df)
    df.columns = df.columns.str.strip()

    for col_name in [COLUNA_CHAVE] + COLUNAS_CHAVE_COMPOSTA:
        if col_name in df.columns:
            df[col_name] = df[col_name].astype(str)

    if COLUNA_CHAVE in df.columns:
        df.dropna(subset=[COLUNA_CHAVE], inplace=True)
        df.drop_duplicates(subset=[COLUNA_CHAVE], inplace=True)

    colunas_presentes = [col for col in COLUNAS_CHAVE_COMPOSTA if col in df.columns]
    if len(colunas_presentes) == len(COLUNAS_CHAVE_COMPOSTA):
        df['CHAVE_COMPOSTA_TEMP'] = df[colunas_presentes].astype(str).agg('-'.join, axis=1)
        df.drop_duplicates(subset=['CHAVE_COMPOSTA_TEMP'], inplace=True)
        df.drop(columns=['CHAVE_COMPOSTA_TEMP'], inplace=True)

    if COLUNA_DATA in df.columns:
        df[COLUNA_DATA] = pd.to_datetime(df[COLUNA_DATA], errors='coerce')
        df.dropna(subset=[COLUNA_DATA], inplace=True)

    if COLUNA_VALOR in df.columns:
        df[COLUNA_VALOR] = df[COLUNA_VALOR].astype(str).str.replace('.', '', regex=False).str.replace(',', '.', regex=False)
        df[COLUNA_VALOR] = pd.to_numeric(df[COLUNA_VALOR], errors='coerce')
        df.loc[df[COLUNA_VALOR] < 0, COLUNA_VALOR] = np.nan
        df.dropna(subset=[COLUNA_VALOR], inplace=True)

    total_linhas_final = len(df)
    linhas_removidas = total_linhas_original - total_linhas_final

    time.sleep(0.5)
    logging.info(f"--- Limpeza Conclu√≠da. Linhas removidas: {linhas_removidas} ---")
    wrangling_placeholder.text(f"Limpeza conclu√≠da. {linhas_removidas} linhas duplicadas ou inv√°lidas removidas.")
    time.sleep(0.5)

    return df


# --- 3. Ferramentas (Sem altera√ß√µes da v6.5) ---

def get_data_description():
    \"\"\"Retorna uma descri√ß√£o estat√≠stica detalhada do DataFrame...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."

        desc_stats_df = df_global.describe(include='all').transpose()
        info_buffer = io.StringIO()
        df_global.info(buf=info_buffer, verbose=True, memory_usage=False)
        data_types_str = info_buffer.getvalue()

        null_counts = df_global.isnull().sum()
        null_percentage = (df_global.isnull().sum() / len(df_global)) * 100
        null_df = pd.DataFrame({
            'Nulos': null_counts,
            '% Nulos': null_percentage.round(2)
        })

        output_str = "--- Descri√ß√£o de Dados Completa ---\\n\\n"
        output_str += "--- Tipos de Dados e Informa√ß√µes ---\\n"
        output_str += f"```\\n{data_types_str}\\n```\\n"
        output_str += "\\n--- Estat√≠sticas Descritivas ---\\n"
        output_str += desc_stats_df.to_markdown()
        output_str += "\\n\\n--- Contagem de Nulos ---\\n"
        output_str += null_df.to_markdown()

        output_str += "\\n\\n--- Valores √önicos (Amostra para colunas categ√≥ricas) ---\\n"
        for col in df_global.columns:
            if df_global[col].nunique() < 20 and df_global[col].dtype == 'object':
                unique_str = ", ".join(df_global[col].unique()[:5])
                if len(unique_str) > 100: unique_str = unique_str[:100] + "..."
                output_str += f"**{col}:** {unique_str}\\n"

        return output_str
    except Exception as e:
        logging.error(f"Erro ao gerar descri√ß√£o: {e}")
        return f"Erro ao gerar descri√ß√£o: {e}"

def calculate_summary_stats(column_name: str):
    \"\"\"Calcula M√©dia, Mediana, Desvio Padr√£o e Vari√¢ncia...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."
        if column_name not in df_global.columns:
            return f"Erro: Coluna '{column_name}' n√£o encontrada. Colunas: {df_global.columns.tolist()}"
        col = df_global[column_name]
        if not np.issubdtype(col.dtype, np.number):
            return f"Erro: Coluna '{column_name}' n√£o √© num√©rica."
        stats = {
            "M√©dia": col.mean(),
            "Mediana": col.median(),
            "Desvio Padr√£o": col.std(),
            "Vari√¢ncia": col.var(),
            "M√≠nimo": col.min(),
            "M√°ximo": col.max(),
            "Contagem": col.count()
        }
        stats_df = pd.DataFrame([stats], index=[column_name]).transpose()
        return stats_df.to_markdown()
    except Exception as e:
        logging.error(f"Erro ao calcular estat√≠sticas para {column_name}: {e}")
        return f"Erro ao calcular estat√≠sticas para {column_name}: {e}"

def generate_correlation_matrix_plot():
    \"\"\"Gera o gr√°fico da Matriz de Correla√ß√£o...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."
        plt.close('all')
        df_num = df_global.select_dtypes(include=np.number).copy()
        colunas_constantes = [col for col in df_num.columns if df_num[col].nunique() <= 1]
        df_num = df_num.drop(columns=colunas_constantes)
        if df_num.shape[1] < 2:
            return "N√£o h√° colunas num√©ricas suficientes para Matriz de Correla√ß√£o."
        corr = df_num.corr()
        plt.figure(figsize=(10, 10)); plt.matshow(corr, fignum=plt.gcf().number)
        cols = corr.columns; plt.xticks(range(len(cols)), cols, rotation=90); plt.yticks(range(len(cols)), cols)
        plt.colorbar(); plt.title('Matriz de Correla√ß√£o', fontsize=15)
        output_path = "correlation_matrix.png"
        plt.savefig(output_path); plt.close()
        return f"Sucesso: Gr√°fico de Matriz de Correla√ß√£o salvo em {output_path}."
    except Exception as e:
        logging.error(f"Erro no gr√°fico de correla√ß√£o: {e}")
        return f"Erro ao gerar o gr√°fico de correla√ß√£o: {e}"

def generate_distribution_plot(column_name: str):
    \"\"\"Gera um gr√°fico de distribui√ß√£o...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."
        if column_name not in df_global.columns:
            return f"Erro: Coluna '{column_name}' n√£o encontrada. Colunas: {df_global.columns.tolist()}"
        plt.close('all'); plt.figure(figsize=(10, 6))
        col = df_global[column_name].dropna()
        if col.empty:
            return f"Coluna '{column_name}' est√° vazia ou cont√©m apenas valores nulos."

        if np.issubdtype(col.dtype, np.number):
            col.hist(bins=50, edgecolor='black'); plt.title(f'Histograma de {column_name}')
            plt.xlabel(column_name); plt.ylabel('Frequ√™ncia')
        elif pd.api.types.is_datetime64_any_dtype(col):
            monthly_counts = col.dt.to_period('M').value_counts().sort_index()
            if monthly_counts.empty:
                 return f"Coluna de data '{column_name}' n√£o possui valores para plotar."
            monthly_counts.plot(kind='bar', color='skyblue'); plt.title(f'Contagem de Notas por M√™s ({column_name})')
            plt.ylabel('Contagem'); plt.xticks(rotation=60, ha='right')
        else:
            top_counts = col.value_counts().nlargest(20)
            if top_counts.empty:
                return f"Coluna categ√≥rica '{column_name}' n√£o possui valores para plotar."
            top_counts.plot.bar(color='skyblue'); plt.title(f'Contagem de {column_name} (Top {len(top_counts)})')
            plt.ylabel('Contagens'); plt.xticks(rotation=60, ha='right')

        plt.tight_layout()
        safe_col_name = _slugify(column_name)
        output_path = f"distribution_{safe_col_name}.png"
        plt.savefig(output_path, bbox_inches='tight'); plt.close()
        return f"Sucesso: Gr√°fico de Distribui√ß√£o para '{column_name}' salvo em {output_path}."
    except Exception as e:
        logging.error(f"Erro no gr√°fico de distribui√ß√£o para {column_name}: {e}")
        return f"Erro ao gerar gr√°fico de distribui√ß√£o para {column_name}: {e}"

def filter_data(query_string: str, head_rows: int = 10):
    \"\"\"Filtra o DataFrame...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."

        for col in df_global.columns:
            if ' ' in col or '.' in col or '/' in col or '-' in col:
                query_string = query_string.replace(col, f"`{col}`")

        result_df = df_global.query(query_string, engine='python')

        if result_df.empty:
            return "A consulta n√£o retornou resultados."

        response_str = f"Filtro aplicado. Total de {len(result_df)} linhas encontradas. Mostrando as {head_rows} primeiras:\\n\\n"
        response_str += result_df.head(head_rows).to_markdown()
        return response_str
    except Exception as e:
        logging.error(f"Erro na consulta '{query_string}': {e}")
        return f"Erro na consulta: {e}. Lembre-se que nomes de coluna com espa√ßo precisam de crase (ex: `NOME COLUNA`)."

def group_and_aggregate(group_by_column: str, agg_column: str, agg_function: str = 'sum', head_rows: int = 10):
    \"\"\"Agrupa o DataFrame...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."

        group_cols = [col.strip() for col in group_by_column.split(',')]

        for col in group_cols:
            if col not in df_global.columns:
                return f"Erro: Coluna de agrupar '{col}' n√£o encontrada. Colunas: {df_global.columns.tolist()}"

        if agg_column not in df_global.columns:
            return f"Erro: Coluna de agregar '{agg_column}' n√£o encontrada. Colunas: {df_global.columns.tolist()}"

        if not hasattr(pd.Series, agg_function):
             return f"Erro: Fun√ß√£o de agrega√ß√£o '{agg_function}' n√£o suportada. Use 'sum', 'mean', 'count', 'min', 'max', etc."

        result_series = df_global.groupby(group_cols)[agg_column].agg(agg_function)

        if isinstance(result_series, pd.Series):
            result_df = result_series.reset_index().rename(columns={agg_column: f"{agg_function.capitalize()} de {agg_column}"})
        else:
            result_df = result_series.reset_index()

        response_str = f"Agrupamento aplicado. Resultado tem {len(result_df)} linhas. Mostrando as {head_rows} primeiras:\\n\\n"
        response_str += result_df.head(head_rows).to_markdown()
        return response_str

    except Exception as e:
        logging.error(f"Erro ao agrupar: {e}")
        return f"Erro ao agrupar: {e}"


available_tools = {
    "get_data_description": get_data_description,
    "calculate_summary_stats": calculate_summary_stats,
    "generate_correlation_matrix_plot": generate_correlation_matrix_plot,
    "generate_distribution_plot": generate_distribution_plot,
    "filter_data": filter_data,
    "group_and_aggregate": group_and_aggregate,
}

# --- 4. L√≥gica de Setup do Chat (Sem altera√ß√µes da v6.1) ---

def setup_chat_session(df):
    global df_global
    df_global = df
    logging.info("‚ú® Iniciando Setup do Chat (Google AI Nativo) ‚ú®")

    try:
        api_key = os.getenv("GEMINI_API_KEY")
        if not api_key:
            st.error("Chave GEMINI_API_KEY n√£o encontrada. Verifique os secrets do Colab.")
            return None
        genai.configure(api_key=api_key)

        system_prompt_str = f\"\"\"
Voc√™ √© "FiscalIA", um Agente de An√°lise de Dados especialista em Notas Fiscais.
Sua miss√£o √© auxiliar o usu√°rio a entender um dataset de notas fiscais.
O dataset tem {df.shape[0]} linhas e {df.shape[1]} colunas.
Use suas ferramentas (tools) para obter dados e gerar gr√°ficos.
SEMPRE que uma ferramenta gerar um gr√°fico, avise o usu√°rio o nome do arquivo (ex: 'correlation_matrix.png').
Seja direto e amig√°vel.
As colunas dispon√≠veis para an√°lise s√£o: {df_global.columns.tolist()}
Quando as ferramentas retornarem dados em formato de tabela (Markdown), exiba-os formatados.
Quando o usu√°rio pedir para 'descrever os dados', use a ferramenta 'get_data_description' e interprete o resultado, mencionando as colunas mais importantes, seus tipos, estat√≠sticas e nulos.
\"\"\"

        model = genai.GenerativeModel(
            model_name="gemini-flash-latest",
            system_instruction=system_prompt_str,
            tools=available_tools.values()
        )

        chat = model.start_chat(enable_automatic_function_calling=True)
        logging.info("‚ú® CHAT FiscalIA ATIVADO ‚ú®")
        return chat

    except Exception as e:
        st.error(f"Falha ao configurar o LLM Gemini: {e}")
        logging.error(f"Falha ao configurar o LLM Gemini: {e}")
        return None

# --- 5. Interface Gr√°fica (Streamlit) ---
def main():
    st.set_page_config(
        page_title="FiscalIA",
        layout="wide",
        page_icon="ü§ñ"
    )

    load_custom_css()

    # --- (IN√çCIO DA MUDAN√áA v7.9) ---

    # Renderiza os elementos da Sidebar
    st.sidebar.markdown("<h1 style='color: #FFFFFF; font-size: 1.75rem;'>ü§ñ FiscalIA</h1>", unsafe_allow_html=True)
    st.sidebar.markdown("<p style='color: #E0E0E0;'>üë§ *Usu√°rio An√¥nimo*</p>", unsafe_allow_html=True)
    st.sidebar.divider()
    st.sidebar.markdown("<h2 style='color: #FFFFFF; font-size: 1.25rem;'>Controles</h2>", unsafe_allow_html=True)

    # Bot√£o 1: Rein√≠cio Total (Sempre vis√≠vel)
    if st.sidebar.button("Limpar e Reiniciar Sess√£o", key="clear_session_button", type="primary"):
        keys_to_clear = ["agent_ready", "messages", "chat_session", "df_global_processed", "prompt_sugerido", "question_select_key", "chart_select_key"]
        for key in keys_to_clear:
            if key in st.session_state:
                del st.session_state[key]
        st.rerun()

    # Inicializa o estado da sess√£o (padr√£o)
    if "agent_ready" not in st.session_state: st.session_state.agent_ready = False
    if "messages" not in st.session_state: st.session_state.messages = []
    if "chat_session" not in st.session_state: st.session_state.chat_session = None
    if "df_global_processed" not in st.session_state: st.session_state.df_global_processed = None

    # Bot√£o 2: Limpar Chat (Apenas se o agente estiver pronto)
    if st.session_state.agent_ready:
        if st.sidebar.button("Limpar Hist√≥rico do Chat", key="clear_chat_button", type="primary"):
            st.session_state.messages = [st.session_state.messages[0]]
            if "prompt_sugerido" in st.session_state:
                del st.session_state.prompt_sugerido
            st.rerun()

        st.sidebar.divider()
        # Caixa de "Sobre" com estilo for√ßado
        st.sidebar.markdown(\"\"\"
            <div style="background-color: #3730A3; border-radius: 6px; padding: 16px; border: none;">
                <p style="color: #FFFFFF; margin-bottom: 0;">
                    <b>Sobre o FiscalIA v7.9:</b><br>
                    Este app usa IA (Google Gemini) para analisar arquivos de notas fiscais.
                    O processamento √© feito em mem√≥ria e seus arquivos n√£o s√£o salvos.
                </p>
            </div>
        \"\"\", unsafe_allow_html=True)
    # --- (FIM DA MUDAN√áA v7.9) ---


    if not st.session_state.agent_ready:
        st.title("Analista de Notas Fiscais")
        # Container de Upload (Cart√£o Branco)
        with st.container(border=True):
            st.markdown("Bem-vindo! Sou o **FiscalIA**, seu assistente para an√°lise de notas fiscais.")
            st.markdown("Por favor, fa√ßa o **upload dos seus arquivos .csv, .xlsx ou .xls** abaixo.")

            uploaded_files = st.file_uploader(
                "Selecione um ou mais arquivos CSV/Excel:",
                type=["csv", "xlsx", "xls"],
                accept_multiple_files=True,
                label_visibility="collapsed"
            )

            if st.button("Analisar Arquivos üöÄ", key="analyze_button", type="primary"):
                if not uploaded_files:
                     st.error("Por favor, fa√ßa o upload de pelo menos um arquivo CSV ou Excel.")
                     st.stop()

                with st.spinner("Carregando e processando arquivos..."):
                    df = carregar_arquivos_upload(uploaded_files)

                    if df is not None:
                        df = run_data_wrangling(df)

                        if df is not None:
                            st.session_state.df_global_processed = df
                            st.session_state.chat_session = setup_chat_session(df)

                            if st.session_state.chat_session:
                                st.session_state.agent_ready = True
                                st.session_state.messages = [{
                                    "role": "assistant",
                                    "content": f"Pronto! Analisei {df.shape[0]} notas fiscais ({df.shape[1]} colunas). Como posso ajudar?"
                                }]
                                st.success(f"An√°lise conclu√≠da! {df.shape[0]} linhas prontas.")
                                time.sleep(1)
                                st.rerun()
                            else: st.error("Falha ao inicializar o agente de IA.")
                        else: st.error("Falha ao limpar os dados.")
                    else:
                        pass

    else:
        st.header("Resultados da An√°lise")

        global df_global
        df_global = st.session_state.df_global_processed

        tab_chat, tab_dashboard = st.tabs(["üí¨ Chat com FiscalIA", "üìä Dashboard de Dados"])

        with tab_chat:
            question_options = {
                "Selecione uma pergunta...": None,
                "Descreva os dados": "Descreva os dados",
                "Qual o valor total das notas?": "calcule a soma da coluna 'VALOR NOTA FISCAL'",
                "Qual o valor m√©dio das notas?": "calcule a m√©dia da coluna 'VALOR NOTA FISCAL'",
                "Tabela: Top 10 Clientes por Valor": "agrupe por 'NOME DESTINAT√ÅRIO' e some 'VALOR NOTA FISCAL', mostrando os 10 maiores",
                "Tabela: Top 10 Fornecedores por Valor": "agrupe por 'RAZ√ÉO SOCIAL EMITENTE' e some 'VALOR NOTA FISCAL', mostrando os 10 maiores",
                "Tabela: Valor por Status da Nota (Canceladas?)": "agrupe por 'EVENTO MAIS RECENTE' e some 'VALOR NOTA FISCAL'",
                "Tabela: Valor por Rota (UF Origem/Destino)": "agrupe por 'UF EMITENTE, UF DESTINAT√ÅRIO' e some 'VALOR NOTA FISCAL'",
                "Tabela: Notas com valor acima de R$ 100.000": "filtre os dados com a query '`VALOR NOTA FISCAL` > 100000'",
                "Tabela: Notas com valor abaixo de R$ 50": "filtre os dados com a query '`VALOR NOTA FISCAL` < 50'",
                "Tabela: Quantidade de notas por UF de Destino": "agrupe por 'UF DESTINAT√ÅRIO' e conte 'CHAVE DE ACESSO' (use a fun√ß√£o 'count')"
            }

            chart_options = {
                "Selecione um gr√°fico...": None,
                "Gr√°fico: Histograma de Valores": "gere um histograma da coluna 'VALOR NOTA FISCAL'",
                "Gr√°fico: Top 10 Munic√≠pios Emitentes": "gere um gr√°fico de barras para a coluna 'MUNIC√çPIO EMITENTE'",
                "Gr√°fico: Valor por Estado de Destino (UF)": "gere um gr√°fico de barras para a coluna 'UF DESTINAT√ÅRIO'",
                "Gr√°fico: Notas ao Longo do Tempo (por M√™s)": "gere um gr√°fico de distribui√ß√£o para a coluna 'DATA EMISS√ÉO'",
                "Gr√°fico: Situa√ß√£o das Notas (Canceladas?)": "gere um gr√°fico de barras para a coluna 'EVENTO MAIS RECENTE'"
            }

            def on_suggestion_select():
                q_prompt = question_options.get(st.session_state.question_select_key)
                c_prompt = chart_options.get(st.session_state.chart_select_key)

                if q_prompt: st.session_state.prompt_sugerido = q_prompt
                elif c_prompt: st.session_state.prompt_sugerido = c_prompt

                st.session_state.question_select_key = "Selecione uma pergunta..."
                st.session_state.chart_select_key = "Selecione um gr√°fico..."

            # --- (IN√çCIO DA MUDAN√áA v7.9) ---
            # Coloca os combos dentro de um "cart√£o" branco
            with st.container(border=True):
                col1, col2 = st.columns(2)
                with col1:
                    st.selectbox(
                        "Sugest√µes de Perguntas:",
                        options=question_options.keys(),
                        key="question_select_key",
                        on_change=on_suggestion_select
                    )
                with col2:
                    st.selectbox(
                        "Sugest√µes de Gr√°ficos:",
                        options=chart_options.keys(),
                        key="chart_select_key",
                        on_change=on_suggestion_select
                    )
            # --- (FIM DA MUDAN√áA v7.9) ---

            st.markdown("---")

            chat_container = st.container(height=600, border=False)
            with chat_container:
                for message in st.session_state.messages:
                    with st.chat_message(message["role"]):
                        st.markdown(message["content"])
                        if 'image_path' in message:
                            st.image(message['image_path'])

            user_prompt = st.chat_input("Pergunte sobre seus dados...")

            if st.session_state.get("prompt_sugerido"):
                user_prompt = st.session_state.pop("prompt_sugerido")

            if user_prompt:
                st.session_state.messages.append({"role": "user", "content": user_prompt})
                st.rerun()

            if st.session_state.messages and st.session_state.messages[-1]["role"] == "user":
                with chat_container:
                    with st.chat_message("user"):
                         st.markdown(st.session_state.messages[-1]["content"])

                with chat_container:
                    with st.chat_message("assistant"):
                        placeholder = st.empty()
                        placeholder.markdown("FiscalIA est√° pensando... üß†")

                        try:
                            chat = st.session_state.chat_session
                            last_user_prompt = st.session_state.messages[-1]["content"]
                            response = chat.send_message(last_user_prompt)

                            output_text = response.text
                            response_message = {"role": "assistant", "content": output_text}

                            placeholder.markdown(output_text)

                            img_match = re.search(r'([a-zA-Z0-9_\\-]+\\.(png|jpg))', output_text)
                            if img_match and os.path.exists(img_match.group(1)):
                                img_path = img_match.group(1)
                                response_message["image_path"] = img_path
                                st.image(img_path)

                            st.session_state.messages.append(response_message)

                            if st.session_state.get("prompt_sugerido"):
                                st.session_state.pop("prompt_sugerido", None)

                            st.rerun()

                        except Exception as e:
                            logging.error(f"Erro na execu√ß√£o do chat: {e}")
                            error_msg = f"Desculpe, ocorreu um erro: {e}. Por favor, tente novamente."
                            st.session_state.messages.append({"role": "assistant", "content": error_msg})
                            placeholder.error(error_msg)

        with tab_dashboard:
            if df_global is not None:
                st.header("üìä Dashboard de Dados")

                try:
                    coluna_valor_encontrada = None
                    colunas_possiveis = ['VALOR NOTA FISCAL', 'VALOR NOTA', 'VALOR']
                    for col in colunas_possiveis:
                        if col in df_global.columns:
                            coluna_valor_encontrada = col
                            break

                    if coluna_valor_encontrada:
                        total_valor = df_global[coluna_valor_encontrada].sum()
                        total_notas = len(df_global)
                        valor_medio = df_global[coluna_valor_encontrada].mean()

                        col_met1, col_met2, col_met3 = st.columns(3)
                        with col_met1:
                            st.metric(label="Valor Total das Notas", value=f"R$ {total_valor:,.2f}")
                        with col_met2:
                            st.metric(label="Total de Notas Fiscais", value=f"{total_notas}")
                        with col_met3:
                            st.metric(label="Valor M√©dio por Nota", value=f"R$ {valor_medio:,.2f}")
                    else:
                        st.warning("N√£o foi poss√≠vel calcular as m√©tricas. Coluna 'VALOR NOTA FISCAL' n√£o encontrada.")

                except Exception as e:
                    st.error(f"Erro ao calcular m√©tricas: {e}")

                st.markdown("---")

                st.subheader(f"Vis√£o Detalhada ({df_global.shape[0]} linhas)")

                @st.cache_data
                def convert_df_to_csv(df):
                    return df.to_csv(index=False).encode('utf-8')

                csv_limpo = convert_df_to_csv(df_global)
                st.download_button(
                     label="‚¨áÔ∏è Baixar dados limpos (.csv)",
                     data=csv_limpo,
                     file_name="dados_fiscais_limpos.csv",
                     mime="text/csv",
                     key="download_csv_button"
                )

                st.dataframe(df_global, use_container_width=True, height=600)
            else:
                st.warning("Nenhum dado processado ainda. Fa√ßa o upload na aba de chat.")

if __name__ == "__main__":
    main()
"""

# Escreve o arquivo app.py
try:
    with open("app.py", "w", encoding='utf-8') as f:
        f.write(app_py_content)
    print("‚úÖ Arquivo 'app.py' (v7.9) criado com sucesso.")
except Exception as e:
    print(f"‚ùå Erro ao escrever app.py: {e}")

#@title C√âLULA 2: L√≥gica da Aplica√ß√£o
import os
import io
import sys
import re
import logging
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import streamlit as st
import unicodedata
import time

# --- 1. Cria o arquivo de Tema (.streamlit/config.toml) ---
os.makedirs(".streamlit", exist_ok=True)

config_toml_content = """
[theme]
# Cor prim√°ria (azul/roxo)
primaryColor="#5A55D1"
# Cor de fundo principal (cinza bem claro)
backgroundColor="#F4F6F9"
# Cor de fundo de widgets e cart√µes (branco)
secondaryBackgroundColor="#FFFFFF"
# Cor do texto principal (cinza escuro)
textColor="#1F1F1F"
# Fonte padr√£o
font="sans serif"
"""
try:
    with open(".streamlit/config.toml", "w") as f:
        f.write(config_toml_content)
    print("‚úÖ Arquivo de tema 'config.toml' (v7.11) criado com sucesso.")
except Exception as e:
    print(f"‚ùå Erro ao escrever config.toml: {e}")


# --- 2. Cria o App (app.py) ---
app_py_content = """
import os
import io
import sys
import re
import logging
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import streamlit as st
import unicodedata # Para normalizar nomes de arquivos
import time # Para simular carregamento

# Imports de IA (Nativo do Google)
import google.generativeai as genai
from google.generativeai.types import GenerationConfig, FunctionDeclaration, Tool

# Configura o backend do Matplotlib
matplotlib.use("Agg")

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)

# Vari√°vel global para o DataFrame
df_global = None

def _slugify(text):
    \"\"\"
    Converte texto em um "slug" seguro para nomes de arquivos.
    Ex: "MUNIC√çPIO EMITENTE" -> "municipio_emitente"
    \"\"\"
    try:
        text = unicodedata.normalize('NFD', text)
        text = text.encode('ascii', 'ignore').decode('utf-8')
    except Exception:
        pass

    text = text.lower()
    text = re.sub(r'[^a-z0-9_\\-]', '_', text)
    text = re.sub(r'__+', '_', text)
    text = text.strip('_')

    if not text:
        text = "arquivo_grafico"

    return text

# --- (IN√çCIO DA MUDAN√áA: v7.11) ---

def load_custom_css():
    \"\"\"Injeta CSS customizado para o design 'Bigscoots' (v7.11).\"\"\"
    st.markdown(\"\"\"
        <style>
            /* Fonte principal */
            html, body, [class*="st-"] {
                font-family: 'sans serif', sans-serif;
            }

            /* Esconde o cabe√ßalho padr√£o */
            .stApp [data-testid="stHeader"] {
                display: none;
            }

            /* --- Barra Lateral (Sidebar) --- */
            [data-testid="stSidebar"] {
                background-color: #312E81 !important; /* Fundo Roxo/Azul Escuro */
                padding-top: 1.5rem !important;
            }

            [data-testid="stSidebar"] h1 { color: #FFFFFF !important; }
            [data-testid="stSidebar"] h2 { color: #FFFFFF !important; }
            [data-testid="stSidebar"] .stMarkdown p { color: #E0E0E0 !important; }
            [data-testid="stSidebar"] .stButton>button {
                background-color: var(--primaryColor) !important;
                color: #FFFFFF !important;
                border: none !important;
                border-radius: 6px !important;
                width: 100% !important;
            }
            [data-testid="stSidebar"] .stButton>button:hover {
                background-color: #6366F1 !important;
                color: #FFFFFF !important;
            }
            [data-testid="stSidebar"] .stButton>button:not(:hover) {
                background-color: var(--primaryColor) !important;
                color: #FFFFFF !important;
            }
            [data-testid="stSidebar"] [data-testid="stAlert"] {
                background-color: #3730A3 !important;
                border: none !important;
            }
            [data-testid="stSidebar"] [data-testid="stAlert"] * {
                color: #FFFFFF !important;
            }

            /* --- Abas (Tabs) --- */
            .stTabs [data-baseweb="tab"] {
                border-radius: 6px 6px 0 0;
            }

            /* --- Cart√µes (Dashboard e Chat) --- */
            [data-testid="chat-message-container"] {
                border-radius: 12px; padding: 1.25rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.04);
                border: 1px solid #E5E7EB;
            }
            [data-testid="chat-message-container"]:has([data-testid="chat-avatar-user"]) {
                background-color: #F4F6F9;
            }
            [data-testid="stMetric"] {
                background-color: var(--secondaryBackgroundColor);
                border: 1px solid #E5E7EB;
                border-radius: 10px; padding: 1.5rem;
                box-shadow: 0 4px 6px rgba(0,0,0,0.04);
            }

            /* --- Combos (Selectbox) no Chat --- */
            /* Deixamos os combos brancos (padr√£o), pois eles
               agora est√£o dentro de um cart√£o branco */
            [data-testid="stTabs"] [data-testid="stSelectbox"] {
                 background-color: #FFFFFF !important;
            }

            /* --- Estilo da TELA DE LOGIN (SPLASH) --- */

            /* Esconde a sidebar na tela de splash */
            .splash-screen [data-testid="stSidebar"] {
                display: none !important;
            }

            /* Centraliza e colore o T√≠tulo da Splash */
            .splash-screen h1[data-testid="stHeading"] {
                color: var(--primaryColor) !important; /* Cor Roxo/Azul */
                text-align: center !important;
                padding-top: 3rem !important;
            }

            /* Estiliza o "cart√£o" de login */
            .splash-screen [data-testid="stVerticalBlockBorderWrapper"] > div[data-testid="stVerticalBlock"] {
                background-color: #FFFFFF !important;
                border-radius: 12px !important;
                box-shadow: 0 8px 16px rgba(0,0,0,0.1) !important;
                border: 1px solid #E0E0E0 !important;
            }

        </style>
    \"\"\", unsafe_allow_html=True)
# --- (FIM DA MUDAN√áA: v7.11) ---


# --- 2. Fun√ß√µes de Carregamento (Sem altera√ß√µes da v6.1) ---

def carregar_arquivos_upload(lista_de_arquivos_upload, **kwargs):
    \"\"\"Carrega e concatena arquivos CSV/Excel do st.file_uploader.\"\"\"
    dataframes = []

    if not lista_de_arquivos_upload:
        st.error("Nenhum arquivo enviado.")
        return None

    csv_configuracoes_prioritarias = [
        {'sep': ';', 'decimal': ',', 'encoding': 'latin-1'},
        {'sep': ';', 'decimal': '.', 'encoding': 'latin-1'},
    ]
    csv_separadores_fallback = [',', '\t', '|']
    csv_encodings_fallback = ['Windows-1252', 'utf-8']

    progress_bar = st.progress(0, "Carregando arquivos...")

    for i, arquivo_upload in enumerate(lista_de_arquivos_upload):
        temp_df = None; sucesso = False
        file_extension = os.path.splitext(arquivo_upload.name)[1].lower()
        logging.info(f"  Tentando carregar: {arquivo_upload.name} (Tipo: {file_extension})")

        arquivo_upload.seek(0)

        if file_extension == '.csv':
            for config in csv_configuracoes_prioritarias:
                try:
                    temp_df = pd.read_csv(arquivo_upload, **config, engine='python', on_bad_lines='warn', **kwargs)
                    arquivo_upload.seek(0)
                    if len(temp_df.columns) > 1: sucesso = True; break
                except Exception:
                    arquivo_upload.seek(0); continue

            if not sucesso:
                for sep in csv_separadores_fallback:
                    for enc in csv_encodings_fallback:
                        try:
                            temp_df = pd.read_csv(arquivo_upload, sep=sep, encoding=enc, engine='python', on_bad_lines='warn', **kwargs)
                            arquivo_upload.seek(0)
                            if len(temp_df.columns) > 1: sucesso = True; break
                        except Exception:
                            arquivo_upload.seek(0); continue
                    if sucesso: break

        elif file_extension in ['.xlsx', '.xls']:
            try:
                temp_df = pd.read_excel(arquivo_upload, engine='openpyxl', **kwargs)
                if len(temp_df.columns) > 1: sucesso = True
            except Exception as e:
                logging.error(f"Erro ao ler arquivo Excel {arquivo_upload.name}: {e}")
                st.warning(f"Erro ao ler Excel {arquivo_upload.name}: {e}")

        else:
            st.warning(f"Formato de arquivo '{file_extension}' n√£o suportado para {arquivo_upload.name}.")

        if sucesso:
            dataframes.append(temp_df)
        else:
            logging.warning(f"‚ùå Falha ao carregar o arquivo {arquivo_upload.name}.")
            st.warning(f"N√£o foi poss√≠vel ler o arquivo: {arquivo_upload.name}. Verifique o formato ou encoding.")

        progress_bar.progress((i + 1) / len(lista_de_arquivos_upload), f"Carregando: {arquivo_upload.name}")

    if dataframes:
        try:
            time.sleep(0.5)
            df_concat = pd.concat(dataframes, ignore_index=True)
            logging.info(f"\\n‚úÖ DataFrame 'df' carregado. Shape final: {df_concat.shape}")
            progress_bar.success("Arquivos carregados e concatenados!")
            time.sleep(0.5)
            return df_concat
        except Exception as e:
            logging.error(f"‚ùå Erro ao concatenar DataFrames: {e}")
            st.error(f"Erro ao concatenar arquivos: {e}")
            return None
    else:
        logging.error("‚ùå Nenhum DataFrame foi carregado.")
        st.error("Nenhum arquivo CSV/Excel p√¥de ser lido com sucesso.")
        return None

def run_data_wrangling(df):
    \"\"\"Aplica a limpeza de dados e valida√ß√£o fiscal.\"\"\"
    if df is None: return None

    wrangling_placeholder = st.empty()
    wrangling_placeholder.text("Iniciando limpeza e valida√ß√£o dos dados...")

    COLUNA_CHAVE = 'CHAVE DE ACESSO'; COLUNA_DATA = 'DATA EMISS√ÉO'; COLUNA_VALOR = 'VALOR NOTA FISCAL'
    COLUNAS_CHAVE_COMPOSTA = ['S√âRIE', 'N√öMERO', 'MUNIC√çPIO EMITENTE', 'CPF/CNPJ Emitente']

    total_linhas_original = len(df)
    df.columns = df.columns.str.strip()

    for col_name in [COLUNA_CHAVE] + COLUNAS_CHAVE_COMPOSTA:
        if col_name in df.columns:
            df[col_name] = df[col_name].astype(str)

    if COLUNA_CHAVE in df.columns:
        df.dropna(subset=[COLUNA_CHAVE], inplace=True)
        df.drop_duplicates(subset=[COLUNA_CHAVE], inplace=True)

    colunas_presentes = [col for col in COLUNAS_CHAVE_COMPOSTA if col in df.columns]
    if len(colunas_presentes) == len(COLUNAS_CHAVE_COMPOSTA):
        df['CHAVE_COMPOSTA_TEMP'] = df[colunas_presentes].astype(str).agg('-'.join, axis=1)
        df.drop_duplicates(subset=['CHAVE_COMPOSTA_TEMP'], inplace=True)
        df.drop(columns=['CHAVE_COMPOSTA_TEMP'], inplace=True)

    if COLUNA_DATA in df.columns:
        df[COLUNA_DATA] = pd.to_datetime(df[COLUNA_DATA], errors='coerce')
        df.dropna(subset=[COLUNA_DATA], inplace=True)

    if COLUNA_VALOR in df.columns:
        df[COLUNA_VALOR] = df[COLUNA_VALOR].astype(str).str.replace('.', '', regex=False).str.replace(',', '.', regex=False)
        df[COLUNA_VALOR] = pd.to_numeric(df[COLUNA_VALOR], errors='coerce')
        df.loc[df[COLUNA_VALOR] < 0, COLUNA_VALOR] = np.nan
        df.dropna(subset=[COLUNA_VALOR], inplace=True)

    total_linhas_final = len(df)
    linhas_removidas = total_linhas_original - total_linhas_final

    time.sleep(0.5)
    logging.info(f"--- Limpeza Conclu√≠da. Linhas removidas: {linhas_removidas} ---")
    wrangling_placeholder.text(f"Limpeza conclu√≠da. {linhas_removidas} linhas duplicadas ou inv√°lidas removidas.")
    time.sleep(0.5)

    return df


# --- 3. Ferramentas (Sem altera√ß√µes da v6.5) ---

def get_data_description():
    \"\"\"Retorna uma descri√ß√£o estat√≠stica detalhada do DataFrame...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."

        desc_stats_df = df_global.describe(include='all').transpose()
        info_buffer = io.StringIO()
        df_global.info(buf=info_buffer, verbose=True, memory_usage=False)
        data_types_str = info_buffer.getvalue()

        null_counts = df_global.isnull().sum()
        null_percentage = (df_global.isnull().sum() / len(df_global)) * 100
        null_df = pd.DataFrame({
            'Nulos': null_counts,
            '% Nulos': null_percentage.round(2)
        })

        output_str = "--- Descri√ß√£o de Dados Completa ---\\n\\n"
        output_str += "--- Tipos de Dados e Informa√ß√µes ---\\n"
        output_str += f"```\\n{data_types_str}\\n```\\n"
        output_str += "\\n--- Estat√≠sticas Descritivas ---\\n"
        output_str += desc_stats_df.to_markdown()
        output_str += "\\n\\n--- Contagem de Nulos ---\\n"
        output_str += null_df.to_markdown()

        output_str += "\\n\\n--- Valores √önicos (Amostra para colunas categ√≥ricas) ---\\n"
        for col in df_global.columns:
            if df_global[col].nunique() < 20 and df_global[col].dtype == 'object':
                unique_str = ", ".join(df_global[col].unique()[:5])
                if len(unique_str) > 100: unique_str = unique_str[:100] + "..."
                output_str += f"**{col}:** {unique_str}\\n"

        return output_str
    except Exception as e:
        logging.error(f"Erro ao gerar descri√ß√£o: {e}")
        return f"Erro ao gerar descri√ß√£o: {e}"

def calculate_summary_stats(column_name: str):
    \"\"\"Calcula M√©dia, Mediana, Desvio Padr√£o e Vari√¢ncia...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."
        if column_name not in df_global.columns:
            return f"Erro: Coluna '{column_name}' n√£o encontrada. Colunas: {df_global.columns.tolist()}"
        col = df_global[column_name]
        if not np.issubdtype(col.dtype, np.number):
            return f"Erro: Coluna '{column_name}' n√£o √© num√©rica."
        stats = {
            "M√©dia": col.mean(),
            "Mediana": col.median(),
            "Desvio Padr√£o": col.std(),
            "Vari√¢ncia": col.var(),
            "M√≠nimo": col.min(),
            "M√°ximo": col.max(),
            "Contagem": col.count()
        }
        stats_df = pd.DataFrame([stats], index=[column_name]).transpose()
        return stats_df.to_markdown()
    except Exception as e:
        logging.error(f"Erro ao calcular estat√≠sticas para {column_name}: {e}")
        return f"Erro ao calcular estat√≠sticas para {column_name}: {e}"

def generate_correlation_matrix_plot():
    \"\"\"Gera o gr√°fico da Matriz de Correla√ß√£o...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."
        plt.close('all')
        df_num = df_global.select_dtypes(include=np.number).copy()
        colunas_constantes = [col for col in df_num.columns if df_num[col].nunique() <= 1]
        df_num = df_num.drop(columns=colunas_constantes)
        if df_num.shape[1] < 2:
            return "N√£o h√° colunas num√©ricas suficientes para Matriz de Correla√ß√£o."
        corr = df_num.corr()
        plt.figure(figsize=(10, 10)); plt.matshow(corr, fignum=plt.gcf().number)
        cols = corr.columns; plt.xticks(range(len(cols)), cols, rotation=90); plt.yticks(range(len(cols)), cols)
        plt.colorbar(); plt.title('Matriz de Correla√ß√£o', fontsize=15)
        output_path = "correlation_matrix.png"
        plt.savefig(output_path); plt.close()
        return f"Sucesso: Gr√°fico de Matriz de Correla√ß√£o salvo em {output_path}."
    except Exception as e:
        logging.error(f"Erro no gr√°fico de correla√ß√£o: {e}")
        return f"Erro ao gerar o gr√°fico de correla√ß√£o: {e}"

def generate_distribution_plot(column_name: str):
    \"\"\"Gera um gr√°fico de distribui√ß√£o...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."
        if column_name not in df_global.columns:
            return f"Erro: Coluna '{column_name}' n√£o encontrada. Colunas: {df_global.columns.tolist()}"
        plt.close('all'); plt.figure(figsize=(10, 6))
        col = df_global[column_name].dropna()
        if col.empty:
            return f"Coluna '{column_name}' est√° vazia ou cont√©m apenas valores nulos."

        if np.issubdtype(col.dtype, np.number):
            col.hist(bins=50, edgecolor='black'); plt.title(f'Histograma de {column_name}')
            plt.xlabel(column_name); plt.ylabel('Frequ√™ncia')
        elif pd.api.types.is_datetime64_any_dtype(col):
            monthly_counts = col.dt.to_period('M').value_counts().sort_index()
            if monthly_counts.empty:
                 return f"Coluna de data '{column_name}' n√£o possui valores para plotar."
            monthly_counts.plot(kind='bar', color='skyblue'); plt.title(f'Contagem de Notas por M√™s ({column_name})')
            plt.ylabel('Contagem'); plt.xticks(rotation=60, ha='right')
        else:
            top_counts = col.value_counts().nlargest(20)
            if top_counts.empty:
                return f"Coluna categ√≥rica '{column_name}' n√£o possui valores para plotar."
            top_counts.plot.bar(color='skyblue'); plt.title(f'Contagem de {column_name} (Top {len(top_counts)})')
            plt.ylabel('Contagens'); plt.xticks(rotation=60, ha='right')

        plt.tight_layout()
        safe_col_name = _slugify(column_name)
        output_path = f"distribution_{safe_col_name}.png"
        plt.savefig(output_path, bbox_inches='tight'); plt.close()
        return f"Sucesso: Gr√°fico de Distribui√ß√£o para '{column_name}' salvo em {output_path}."
    except Exception as e:
        logging.error(f"Erro no gr√°fico de distribui√ß√£o para {column_name}: {e}")
        return f"Erro ao gerar gr√°fico de distribui√ß√£o para {column_name}: {e}"

def filter_data(query_string: str, head_rows: int = 10):
    \"\"\"Filtra o DataFrame...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."

        for col in df_global.columns:
            if ' ' in col or '.' in col or '/' in col or '-' in col:
                query_string = query_string.replace(col, f"`{col}`")

        result_df = df_global.query(query_string, engine='python')

        if result_df.empty:
            return "A consulta n√£o retornou resultados."

        response_str = f"Filtro aplicado. Total de {len(result_df)} linhas encontradas. Mostrando as {head_rows} primeiras:\\n\\n"
        response_str += result_df.head(head_rows).to_markdown()
        return response_str
    except Exception as e:
        logging.error(f"Erro na consulta '{query_string}': {e}")
        return f"Erro na consulta: {e}. Lembre-se que nomes de coluna com espa√ßo precisam de crase (ex: `NOME COLUNA`)."

def group_and_aggregate(group_by_column: str, agg_column: str, agg_function: str = 'sum', head_rows: int = 10):
    \"\"\"Agrupa o DataFrame...\"\"\"
    global df_global
    try:
        if df_global is None: return "Erro: DataFrame n√£o carregado."

        group_cols = [col.strip() for col in group_by_column.split(',')]

        for col in group_cols:
            if col not in df_global.columns:
                return f"Erro: Coluna de agrupar '{col}' n√£o encontrada. Colunas: {df_global.columns.tolist()}"

        if agg_column not in df_global.columns:
            return f"Erro: Coluna de agregar '{agg_column}' n√£o encontrada. Colunas: {df_global.columns.tolist()}"

        if not hasattr(pd.Series, agg_function):
             return f"Erro: Fun√ß√£o de agrega√ß√£o '{agg_function}' n√£o suportada. Use 'sum', 'mean', 'count', 'min', 'max', etc."

        result_series = df_global.groupby(group_cols)[agg_column].agg(agg_function)

        if isinstance(result_series, pd.Series):
            result_df = result_series.reset_index().rename(columns={agg_column: f"{agg_function.capitalize()} de {agg_column}"})
        else:
            result_df = result_series.reset_index()

        response_str = f"Agrupamento aplicado. Resultado tem {len(result_df)} linhas. Mostrando as {head_rows} primeiras:\\n\\n"
        response_str += result_df.head(head_rows).to_markdown()
        return response_str

    except Exception as e:
        logging.error(f"Erro ao agrupar: {e}")
        return f"Erro ao agrupar: {e}"


available_tools = {
    "get_data_description": get_data_description,
    "calculate_summary_stats": calculate_summary_stats,
    "generate_correlation_matrix_plot": generate_correlation_matrix_plot,
    "generate_distribution_plot": generate_distribution_plot,
    "filter_data": filter_data,
    "group_and_aggregate": group_and_aggregate,
}

# --- 4. L√≥gica de Setup do Chat (Sem altera√ß√µes da v6.1) ---

def setup_chat_session(df):
    global df_global
    df_global = df
    logging.info("‚ú® Iniciando Setup do Chat (Google AI Nativo) ‚ú®")

    try:
        api_key = os.getenv("GEMINI_API_KEY")
        if not api_key:
            st.error("Chave GEMINI_API_KEY n√£o encontrada. Verifique os secrets do Colab.")
            return None
        genai.configure(api_key=api_key)

        system_prompt_str = f\"\"\"
Voc√™ √© "FiscalIA", um Agente de An√°lise de Dados especialista em Notas Fiscais.
Sua miss√£o √© auxiliar o usu√°rio a entender um dataset de notas fiscais.
O dataset tem {df.shape[0]} linhas e {df.shape[1]} colunas.
Use suas ferramentas (tools) para obter dados e gerar gr√°ficos.
SEMPRE que uma ferramenta gerar um gr√°fico, avise o usu√°rio o nome do arquivo (ex: 'correlation_matrix.png').
Seja direto e amig√°vel.
As colunas dispon√≠veis para an√°lise s√£o: {df_global.columns.tolist()}
Quando as ferramentas retornarem dados em formato de tabela (Markdown), exiba-os formatados.
Quando o usu√°rio pedir para 'descrever os dados', use a ferramenta 'get_data_description' e interprete o resultado, mencionando as colunas mais importantes, seus tipos, estat√≠sticas e nulos.
\"\"\"

        model = genai.GenerativeModel(
            model_name="gemini-flash-latest",
            system_instruction=system_prompt_str,
            tools=available_tools.values()
        )

        chat = model.start_chat(enable_automatic_function_calling=True)
        logging.info("‚ú® CHAT FiscalIA ATIVADO ‚ú®")
        return chat

    except Exception as e:
        st.error(f"Falha ao configurar o LLM Gemini: {e}")
        logging.error(f"Falha ao configurar o LLM Gemini: {e}")
        return None

# --- (IN√çCIO DA MUDAN√áA: v7.11) ---

def render_welcome_screen():
    \"\"\"Mostra a tela de boas-vindas para inserir o nome.\"\"\"

    # Adiciona a classe CSS para a tela de splash
    st.markdown('<div class="splash-screen">', unsafe_allow_html=True)

    # T√≠tulo centralizado e com a cor prim√°ria
    st.markdown(f"<h1 style='text-align: center; color: {st.theme.primaryColor}; padding-top: 3rem;'>Bem-vindo ao FiscalIA ü§ñ</h1>", unsafe_allow_html=True)

    _col1, col_center, _col3 = st.columns([1, 1.5, 1])

    with col_center:
        # 'border=False' para o CSS controlar o visual
        with st.container(border=False):
            st.markdown("Sou o **FiscalIA**, seu assistente de IA para an√°lise de notas fiscais.")
            st.markdown("Para come√ßar, por favor, me diga seu nome:")

            name = st.text_input("Seu nome", key="user_name_input", label_visibility="collapsed", placeholder="Digite seu nome aqui...")

            if st.button("Confirmar", type="primary", use_container_width=True):
                if name:
                    st.session_state.user_name = name
                    st.rerun()
                else:
                    st.error("Por favor, insira um nome para continuar.")

    st.markdown('</div>', unsafe_allow_html=True) # Fecha a classe


def render_main_app():
    \"\"\"Mostra o aplicativo principal (sidebar, chat, dashboard).\"\"\"

    # --- Renderiza a Sidebar ---
    st.sidebar.markdown(f"<h1 style='color: #FFFFFF; font-size: 1.75rem;'>ü§ñ FiscalIA</h1>", unsafe_allow_html=True)
    st.sidebar.markdown(f"<p style='color: #E0E0E0;'>üë§ *{st.session_state.user_name}*</p>", unsafe_allow_html=True)
    st.sidebar.divider()
    st.sidebar.markdown("<h2 style='color: #FFFFFF; font-size: 1.25rem;'>Controles</h2>", unsafe_allow_html=True)

    if st.sidebar.button("Limpar e Reiniciar Sess√£o", key="clear_session_button", type="primary"):
        keys_to_clear = ["agent_ready", "messages", "chat_session", "df_global_processed", "prompt_sugerido", "question_select_key", "chart_select_key", "user_name"]
        for key in keys_to_clear:
            if key in st.session_state:
                del st.session_state[key]
        st.rerun()

    if st.session_state.agent_ready:
        if st.sidebar.button("Limpar Hist√≥rico do Chat", key="clear_chat_button", type="primary"):
            st.session_state.messages = [st.session_state.messages[0]]
            if "prompt_sugerido" in st.session_state:
                del st.session_state.prompt_sugerido
            st.rerun()

        st.sidebar.divider()
        st.sidebar.markdown(\"\"\"
            <div style="background-color: #3730A3; border-radius: 6px; padding: 16px; border: none;">
                <p style="color: #FFFFFF !important; margin-bottom: 0;">
                    <b>Sobre o FiscalIA v7.11:</b><br>
                    Este app usa IA (Google Gemini) para analisar arquivos de notas fiscais.
                    O processamento √© feito em mem√≥ria e seus arquivos n√£o s√£o salvos.
                </p>
            </div>
        \"\"\", unsafe_allow_html=True)

    # --- Renderiza o Conte√∫do Principal ---
    if not st.session_state.agent_ready:
        st.title("Analista de Notas Fiscais")
        with st.container(border=True):
            st.markdown(f"**Ol√°, {st.session_state.user_name}!** Estou pronto para come√ßar.")
            st.markdown("Por favor, fa√ßa o **upload dos seus arquivos .csv, .xlsx ou .xls** abaixo.")

            uploaded_files = st.file_uploader(
                "Selecione um ou mais arquivos CSV/Excel:",
                type=["csv", "xlsx", "xls"],
                accept_multiple_files=True,
                label_visibility="collapsed"
            )

            if st.button("Analisar Arquivos üöÄ", key="analyze_button", type="primary"):
                if not uploaded_files:
                     st.error("Por favor, fa√ßa o upload de pelo menos um arquivo CSV ou Excel.")
                     st.stop()

                with st.spinner("Carregando e processamento arquivos..."):
                    df = carregar_arquivos_upload(uploaded_files)

                    if df is not None:
                        df = run_data_wrangling(df)

                        if df is not None:
                            st.session_state.df_global_processed = df
                            st.session_state.chat_session = setup_chat_session(df)

                            if st.session_state.chat_session:
                                st.session_state.agent_ready = True
                                st.session_state.messages = [{
                                    "role": "assistant",
                                    "content": f"Pronto, {st.session_state.user_name}! Analisei {df.shape[0]} notas fiscais ({df.shape[1]} colunas). Como posso ajudar?"
                                }]
                                st.success(f"An√°lise conclu√≠da! {df.shape[0]} linhas prontas.")
                                time.sleep(1)
                                st.rerun()
                            else: st.error("Falha ao inicializar o agente de IA.")
                        else: st.error("Falha ao limpar os dados.")
                    else:
                        pass
    else:
        st.header("Resultados da An√°lise")

        global df_global
        df_global = st.session_state.df_global_processed

        tab_chat, tab_dashboard = st.tabs(["üí¨ Chat com FiscalIA", "üìä Dashboard de Dados"])

        with tab_chat:

            question_options = {
                "Selecione uma pergunta...": None,
                "Descreva os dados": "Descreva os dados",
                "Qual o valor total das notas?": "calcule a soma da coluna 'VALOR NOTA FISCAL'",
                "Qual o valor m√©dio das notas?": "calcule a m√©dia da coluna 'VALOR NOTA FISCAL'",
                "Tabela: Top 10 Clientes por Valor": "agrupe por 'NOME DESTINAT√ÅRIO' e some 'VALOR NOTA FISCAL', mostrando os 10 maiores",
                "Tabela: Top 10 Fornecedores por Valor": "agrupe por 'RAZ√ÉO SOCIAL EMITENTE' e some 'VALOR NOTA FISCAL', mostrando os 10 maiores",
                "Tabela: Valor por Status da Nota (Canceladas?)": "agrupe por 'EVENTO MAIS RECENTE' e some 'VALOR NOTA FISCAL'",
                "Tabela: Valor por Rota (UF Origem/Destino)": "agrupe por 'UF EMITENTE, UF DESTINAT√ÅRIO' e some 'VALOR NOTA FISCAL'",
                "Tabela: Notas com valor acima de R$ 100.000": "filtre os dados com a query '`VALOR NOTA FISCAL` > 100000'",
                "Tabela: Notas com valor abaixo de R$ 50": "filtre os dados com a query '`VALOR NOTA FISCAL` < 50'",
                "Tabela: Quantidade de notas por UF de Destino": "agrupe por 'UF DESTINAT√ÅRIO' e conte 'CHAVE DE ACESSO' (use a fun√ß√£o 'count')"
            }

            chart_options = {
                "Selecione um gr√°fico...": None,
                "Gr√°fico: Histograma de Valores": "gere um histograma da coluna 'VALOR NOTA FISCAL'",
                "Gr√°fico: Top 10 Munic√≠pios Emitentes": "gere um gr√°fico de barras para a coluna 'MUNIC√çPIO EMITENTE'",
                "Gr√°fico: Valor por Estado de Destino (UF)": "gere um gr√°fico de barras para a coluna 'UF DESTINAT√ÅRIO'",
                "Gr√°fico: Notas ao Longo do Tempo (por M√™s)": "gere um gr√°fico de distribui√ß√£o para a coluna 'DATA EMISS√ÉO'",
                "Gr√°fico: Situa√ß√£o das Notas (Canceladas?)": "gere um gr√°fico de barras para a coluna 'EVENTO MAIS RECENTE'"
            }

            def on_suggestion_select():
                q_prompt = question_options.get(st.session_state.question_select_key)
                c_prompt = chart_options.get(st.session_state.chart_select_key)

                if q_prompt: st.session_state.prompt_sugerido = q_prompt
                elif c_prompt: st.session_state.prompt_sugerido = c_prompt

                st.session_state.question_select_key = "Selecione uma pergunta..."
                st.session_state.chart_select_key = "Selecione um gr√°fico..."

            # Combos dentro de um "cart√£o" branco
            with st.container(border=True):
                col1, col2 = st.columns(2)
                with col1:
                    st.selectbox(
                        "Sugest√µes de Perguntas:",
                        options=question_options.keys(),
                        key="question_select_key",
                        on_change=on_suggestion_select
                    )
                with col2:
                    st.selectbox(
                        "Sugest√µes de Gr√°ficos:",
                        options=chart_options.keys(),
                        key="chart_select_key",
                        on_change=on_suggestion_select
                    )

            st.markdown("<br>", unsafe_allow_html=True)

            chat_container = st.container(height=600, border=False)
            with chat_container:
                for message in st.session_state.messages:
                    with st.chat_message(message["role"]):
                        st.markdown(message["content"])
                        if 'image_path' in message:
                            st.image(message['image_path'])

            user_prompt = st.chat_input("Pergunte sobre seus dados...")

            if st.session_state.get("prompt_sugerido"):
                user_prompt = st.session_state.pop("prompt_sugerido")

            if user_prompt:
                st.session_state.messages.append({"role": "user", "content": user_prompt})
                st.rerun()

            if st.session_state.messages and st.session_state.messages[-1]["role"] == "user":
                with chat_container:
                    with st.chat_message("user"):
                         st.markdown(st.session_state.messages[-1]["content"])

                with chat_container:
                    with st.chat_message("assistant"):
                        placeholder = st.empty()
                        placeholder.markdown("FiscalIA est√° pensando... üß†")

                        try:
                            chat = st.session_state.chat_session
                            last_user_prompt = st.session_state.messages[-1]["content"]
                            response = chat.send_message(last_user_prompt)

                            output_text = response.text
                            response_message = {"role": "assistant", "content": output_text}

                            placeholder.markdown(output_text)

                            img_match = re.search(r'([a-zA-Z0-9_\\-]+\\.(png|jpg))', output_text)
                            if img_match and os.path.exists(img_match.group(1)):
                                img_path = img_match.group(1)
                                response_message["image_path"] = img_path
                                st.image(img_path)

                            st.session_state.messages.append(response_message)

                            if st.session_state.get("prompt_sugerido"):
                                st.session_state.pop("prompt_sugerido", None)

                            st.rerun()

                        except Exception as e:
                            logging.error(f"Erro na execu√ß√£o do chat: {e}")
                            error_msg = f"Desculpe, ocorreu um erro: {e}. Por favor, tente novamente."
                            st.session_state.messages.append({"role": "assistant", "content": error_msg})
                            placeholder.error(error_msg)

        with tab_dashboard:
            if df_global is not None:
                st.header("üìä Dashboard de Dados")

                try:
                    coluna_valor_encontrada = None
                    colunas_possiveis = ['VALOR NOTA FISCAL', 'VALOR NOTA', 'VALOR']
                    for col in colunas_possiveis:
                        if col in df_global.columns:
                            coluna_valor_encontrada = col
                            break

                    if coluna_valor_encontrada:
                        total_valor = df_global[coluna_valor_encontrada].sum()
                        total_notas = len(df_global)
                        valor_medio = df_global[coluna_valor_encontrada].mean()

                        col_met1, col_met2, col_met3 = st.columns(3)
                        with col_met1:
                            st.metric(label="Valor Total das Notas", value=f"R$ {total_valor:,.2f}")
                        with col_met2:
                            st.metric(label="Total de Notas Fiscais", value=f"{total_notas}")
                        with col_met3:
                            st.metric(label="Valor M√©dio por Nota", value=f"R$ {valor_medio:,.2f}")
                    else:
                        st.warning("N√£o foi poss√≠vel calcular as m√©tricas. Coluna 'VALOR NOTA FISCAL' n√£o encontrada.")

                except Exception as e:
                    st.error(f"Erro ao calcular m√©tricas: {e}")

                st.markdown("---")

                st.subheader(f"Vis√£o Detalhada ({df_global.shape[0]} linhas)")

                @st.cache_data
                def convert_df_to_csv(df):
                    return df.to_csv(index=False).encode('utf-8')

                csv_limpo = convert_df_to_csv(df_global)
                st.download_button(
                     label="‚¨áÔ∏è Baixar dados limpos (.csv)",
                     data=csv_limpo,
                     file_name="dados_fiscais_limpos.csv",
                     mime="text/csv",
                     key="download_csv_button"
                )

                st.dataframe(df_global, use_container_width=True, height=600)
            else:
                st.warning("Nenhum dado processado ainda. Fa√ßa o upload na aba de chat.")

def main():
    st.set_page_config(
        page_title="FiscalIA",
        layout="wide",
        page_icon="ü§ñ"
    )

    # Inicializa todos os estados de sess√£o necess√°rios
    if "user_name" not in st.session_state: st.session_state.user_name = None
    if "agent_ready" not in st.session_state: st.session_state.agent_ready = False
    if "messages" not in st.session_state: st.session_state.messages = []
    if "chat_session" not in st.session_state: st.session_state.chat_session = None
    if "df_global_processed" not in st.session_state: st.session_state.df_global_processed = None

    # Carrega o CSS customizado (agora √© universal)
    load_custom_css()

    # Roteador: Mostra a tela de boas-vindas OU o app principal
    if not st.session_state.user_name:
        render_welcome_screen()
    else:
        render_main_app()

if __name__ == "__main__":
    main()
# --- (FIM DA MUDAN√áA: v7.11) ---
"""

# Escreve o arquivo app.py
try:
    with open("app.py", "w", encoding='utf-8') as f:
        f.write(app_py_content)
    print("‚úÖ Arquivo 'app.py' (v7.11) criado com sucesso.")
except Exception as e:
    print(f"‚ùå Erro ao escrever app.py: {e}")

#@title C√âLULA 3: Inicializador (Streamlit + Ngrok)

import os
import sys
import subprocess
import time
import socket
from pyngrok import ngrok
from google.colab import userdata
import logging

# --- Passo 1: Limpando processos antigos ---
print("--- Passo 1: Limpando processos antigos ---")
!pkill -f "streamlit"
!pkill -f "ngrok"
time.sleep(2)

# --- Passo 2: Iniciando o servidor Streamlit em segundo plano ---
print("\n--- Passo 2: Iniciando o servidor Streamlit 'app.py' ---")
# Garantir que o app.py existe
if not os.path.exists("app.py"):
    print("‚ùå ERRO CR√çTICO: Arquivo 'app.py' n√£o encontrado. Execute a C√©lula 2 primeiro.")
    sys.exit(1)

# Desativa o log do Popen para n√£o poluir
logging.getLogger().setLevel(logging.ERROR)

streamlit_process = subprocess.Popen(
    [sys.executable, "-m", "streamlit", "run", "app.py", "--server.port=8501", "--server.headless=true", "--global.developmentMode=false"],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True
)

logging.getLogger().setLevel(logging.INFO) # Reativa o log
print("Servidor Streamlit iniciado em background.")

# --- Passo 3: Aguarda o servidor Streamlit ficar pronto ---
print("\n--- Passo 3: Verificando se o servidor Streamlit est√° pronto ---")
max_wait_time = 60
start_time = time.time()
port_is_ready = False
while time.time() - start_time < max_wait_time:
    try:
        with socket.create_connection(("127.0.0.1", 8501), timeout=1):
            print("‚úÖ Sucesso! O servidor Streamlit est√° rodando na porta 8501.")
            port_is_ready = True
            break
    except (socket.timeout, ConnectionRefusedError):
        print("Aguardando servidor Streamlit (porta 8501)...")
        time.sleep(2)

if not port_is_ready:
    print("\n‚ùå ERRO CR√çTICO: O servidor Streamlit n√£o iniciou a tempo.")
    print("Logs de erro do Streamlit:")
    print(streamlit_process.stderr.read())
    streamlit_process.kill()
else:
    # --- Passo 4: Inicia o t√∫nel ngrok ---
    print("\n--- Passo 4: Criando o t√∫nel p√∫blico com ngrok ---")
    try:
        token = userdata.get("NGROK_AUTHTOKEN")
        if not token:
            print("‚ùå ERRO CR√çTICO: Secret 'NGROK_AUTHTOKEN' n√£o encontrado.")
            sys.exit(1)

        ngrok.set_auth_token(token)
        public_url = ngrok.connect(8501)

        print("\n" + "="*70)
        print(f"‚úÖ‚úÖ‚úÖ SEU APLICATIVO 'FiscalIA' EST√Å NO AR! ‚úÖ‚úÖ‚úÖ")
        print(f"\n   CLIQUE AQUI: {public_url}")
        print("\n" + "="*70)

        # Mant√©m a c√©lula rodando para ver os logs (opcional, mas bom para debug)
        try:
            streamlit_process.wait()
        except KeyboardInterrupt:
            print("\nEncerrando processos...")
            streamlit_process.kill()
            ngrok.disconnect(public_url)
            print("Processos encerrados.")

    except Exception as e:
        print(f"‚ùå ERRO CR√çTICO ao criar o t√∫nel com ngrok: {e}")
        streamlit_process.kill()